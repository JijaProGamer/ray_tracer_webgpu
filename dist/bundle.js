/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const moveJoystick = new JoyStick('moveJoystick');\nconst rotateJoystick = new JoyStick('rotateJoystick');\n\nconst renderer = __webpack_require__(/*! ./renderer/Renderer.js */ \"./src/renderer/Renderer.js\")\nconst Vector3 = __webpack_require__(/*! ./renderer/classes/Vector3.js */ \"./src/renderer/classes/Vector3.js\")\n\nconst Triangle = __webpack_require__(/*! ./renderer/classes/Triangle.js */ \"./src/renderer/classes/Triangle.js\")\nconst Material = __webpack_require__(/*! ./renderer/classes/Material.js */ \"./src/renderer/classes/Material.js\");\nconst Vector2 = __webpack_require__(/*! ./renderer/classes/Vector2.js */ \"./src/renderer/classes/Vector2.js\");\n\nconst canvas = document.querySelector(`canvas[id=\"canvas\"]`)\nconst fpsCounter = document.querySelector(\"#fpsCount\")\nconst sampleCounter = document.querySelector(\"#sampleCount\")\nconst compression = document.querySelector(\"#compression-range\")\nconst FOV = document.querySelector(\"#fov-range\")\n\nconst Renderer = new renderer({ Canvas: canvas });\n\nlet lastCompression = compression.value\nlet isFullScreen = false;\n\nlet map = []\nlet materials = {}\n\n// walls\n\n/*let Khaki = new Material();\nKhaki.Color = new Vector3(0.76, 0.69, 0.56);\nmaterials[\"Khaki\"] = Khaki\n\nlet wallUp = new Sphere()\nwallUp.Position = new Vector3(0, 106, 0)\nwallUp.Radius = 100;\nwallUp.Material = \"Khaki\"\nmap.push(wallUp)\n\nlet wallDown = new Sphere()\nwallDown.Position = new Vector3(0, -106, 0)\nwallDown.Radius = 100;\nwallDown.Material = \"Khaki\"\nmap.push(wallDown)\n\nlet wallFront = new Sphere()\nwallFront.Position = new Vector3(0, 0, 110)\nwallFront.Radius = 100;\nwallFront.Material = \"Khaki\"\nmap.push(wallFront)\n\nlet wallBack = new Sphere()\nwallBack.Position = new Vector3(0, 0, -110)\nwallBack.Radius = 100;\nwallBack.Material = \"Khaki\"\nmap.push(wallBack)\n\nlet Red = new Material();\nRed.Color = new Vector3(0.5, 0.05, 0.05);\nmaterials[\"Red\"] = Red\n\nlet wallLeft = new Sphere()\nwallLeft.Position = new Vector3(-106, 0, 0)\nwallLeft.Radius = 100;\nwallLeft.Material = \"Red\"\nmap.push(wallLeft)\n\nlet Green = new Material();\nGreen.Color = new Vector3(0.05, 0.5, 0.05);\nmaterials[\"Green\"] = Green\n\nlet wallRight = new Sphere()\nwallRight.Position = new Vector3(106, 0, 0)\nwallRight.Radius = 100;\nwallRight.Material = \"Green\"\nmap.push(wallRight)\n\n// light\n\nlet LightMaterial = new Material();\nLightMaterial.Color = new Vector3(1, 1, 1);\nLightMaterial.Emission = new Vector3(5, 5, 5);\nmaterials[\"Light\"] = LightMaterial\n\nlet light = new Sphere()\nlight.Position = new Vector3(0, 2, -6)\nlight.Radius = 1.5;\nlight.Material = \"Light\"\nmap.push(light)\n\n// object\n\nlet object1 = new Sphere()\nobject1.Position = new Vector3(-3, -3.5, 1.25)\nobject1.Radius = 3;\nobject1.Material = \"Khaki\"\nmap.push(object1)\n\nlet object2 = new Sphere()\nobject2.Position = new Vector3(3, -3.5, -1.25)\nobject2.Radius = 3;\nobject2.Material = \"Khaki\"\nmap.push(object2)*/\n\nfunction MakeQuad(Q, u, v, MaterialName){\n  let a = Q;\n  let b = Q.clone().add(u);\n  let d = Q.clone().add(v);\n  let c = Q.clone().add(u).add(v);\n\n  let edge1 = b.clone().subtract(a);\n  let edge2 = c.clone().subtract(a);\n  let normal = edge2.cross(edge1).normalize();\n\n  let tri1 = new Triangle()\n  tri1.a = a;\n  tri1.b = b;\n  tri1.c = c;\n  tri1.uva = new Vector2(0, 0);\n  tri1.uvb = new Vector2(0, 0);\n  tri1.uvc = new Vector2(0, 0);\n  tri1.na = normal;\n  tri1.nb = normal;\n  tri1.nc = normal;\n  tri1.Material = MaterialName\n  map.push(tri1)\n\n  let tri2 = new Triangle()\n  tri2.a = d;\n  tri2.b = a;\n  tri2.c = c;\n  tri2.uva = new Vector2(0, 0);\n  tri2.uvb = new Vector2(0, 0);\n  tri2.uvc = new Vector2(0, 0);\n  tri2.na = normal;\n  tri2.nb = normal;\n  tri2.nc = normal;\n  tri2.Material = MaterialName\n  map.push(tri2)\n}\n\nfunction MakeBox(Q, u, v, w, MaterialName){\n  //MakeQuad(Q, u, v, MaterialName);\n  MakeQuad(Q.clone().add(w), u, v, MaterialName);\n\n  MakeQuad(Q, w, v, MaterialName);\n  MakeQuad(Q, w, u, MaterialName);\n\n  MakeQuad(Q.clone().add(u), v, w, MaterialName);\n  MakeQuad(Q.clone().add(v), u, w, MaterialName);\n}\n\nlet Khaki = new Material();\nKhaki.Color = new Vector3(0.76, 0.69, 0.56);\nmaterials[\"Khaki\"] = Khaki\n\nlet Red = new Material();\nRed.Color = new Vector3(0.5, 0.1, 0.1);\nmaterials[\"Red\"] = Red\n\nlet Green = new Material();\nGreen.Color = new Vector3(0.1, 0.5, 0.1);\nmaterials[\"Green\"] = Green\n\nlet Light = new Material();\nLight.Color = new Vector3(1, 1, 1);\nLight.Emission = new Vector3(10, 10, 10);\nmaterials[\"Light\"] = Light\n\nMakeQuad(new Vector3(-0.5, -1, -3), new Vector3(0, 0, 4), new Vector3(2, 0, 0), \"Khaki\") // bottom\nMakeQuad(new Vector3(-0.5, 1, -3), new Vector3(0, 0, 4), new Vector3(2, 0, 0), \"Khaki\") // top\n\nMakeQuad(new Vector3(-0.5, -1, -3), new Vector3(0, 2, 0), new Vector3(0, 0, 4), \"Red\") // left\nMakeQuad(new Vector3(1.5, -1, -3), new Vector3(0, 2, 0), new Vector3(0, 0, 4), \"Green\") // right\n\nMakeQuad(new Vector3(-0.5, -1, -3), new Vector3(0, 2, 0), new Vector3(2, 0, 0), \"Khaki\") // front\nMakeQuad(new Vector3(-0.5, -1, 1), new Vector3(0, 2, 0), new Vector3(2, 0, 0), \"Khaki\") // back\n\nMakeQuad(new Vector3(0.25, 0.99999, -2), new Vector3(0, 0, 0.5), new Vector3(0.5, 0, 0), \"Light\") // light\n\nMakeBox(\n  new Vector3(0.35, -1, -2.5), \n  new Vector3(0.75, 0, 0), \n  new Vector3(0, 0, 0.75), \n  new Vector3(0, 1.5, 0), \n  \"Khaki\"\n)\n\nMakeBox(\n  new Vector3(-0.25, -1, -1.5), \n  new Vector3(0.75, 0, 0), \n  new Vector3(0, 0, 0.75), \n  new Vector3(0, 0.75, 0), \n  \"Khaki\"\n)\n\nfunction setCanvasSize(){\n  let width \n  let height\n\n  if(isFullScreen){\n    width = canvas.width = window.screen.width;\n    height = canvas.height = window.screen.height;\n    isFullScreen = false;\n\n  } else {\n    width = canvas.width = 86 / 100 * window.screen.width;\n    height = canvas.height = (9 / 16 * canvas.width)\n  }\n\n  canvas.height *= (compression.value / 10) * window.devicePixelRatio\n  canvas.width *= (compression.value / 10) * window.devicePixelRatio;\n\n  canvas.width = Math.ceil(canvas.width / 8) * 8;\n  canvas.height = Math.ceil(canvas.height / 8) * 8;\n\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n\n  Renderer.MakeBuffers(true)\n  Renderer.MakeBindGroups()\n  Renderer.Camera.Position = Renderer.Camera.Position\n}\n\ndocument.addEventListener(\"fullscreenchange\", setCanvasSize)\n\nfunction setCameraRotation(x, y) {\n  Renderer.Camera.Orientation.setFromEulerAngles(x, y)\n  Renderer.Camera.Orientation = Renderer.Camera.Orientation\n  moved = true;\n}\n\nlet moved = false;\n\nasync function init() {\n  await Renderer.Init()\n  setCanvasSize()\n\n  /*let val = 0\n  setInterval(() => {\n    val += 0.25;\n    light.Position.x = Math.cos(val) * 4;\n    light.Position.y = Math.sin(val) * 3;\n    //light.Position.z = Math.sin(-val / 2) * 2;\n\n    //LightMaterial.Emission.x = 5 + Math.cos(val) * 3;\n    //LightMaterial.Emission.g = 5 + Math.sin(val) * 5;\n    Renderer.SetMap(map, materials)\n  }, 100)*/\n  Renderer.SetMap(map, materials)\n\n  let lastFPSDraw = Date.now()\n  let FPSNumber = 0\n\n  canvas.addEventListener('click', () => {\n    canvas.requestPointerLock();\n  });\n\n  let mouseX = 0\n  let mouseY = 0\n  let mouseDPI = 750;\n  let cameraSpeed = 2.5;\n\n  const movement = {\n    forward: false,\n    backward: false,\n    left: false,\n    right: false,\n    up: false,\n    down: false\n  };\n\n  function handleKeyDown(event) {\n    switch (event.key) {\n      case 'w':\n        movement.forward = true;\n        break;\n      case 'a':\n        movement.left = true;\n        break;\n      case 's':\n        movement.backward = true;\n        break;\n      case 'd':\n        movement.right = true;\n        break;\n      case 'q':\n        movement.up = true;\n        break;\n      case 'e':\n        movement.down = true;\n        break;\n\n      case \"o\":\n        if(!isFullScreen){\n          canvas.requestFullscreen()\n          isFullScreen = true;\n        } else {\n          setCanvasSize()\n        }\n\n        break;\n    }\n  }\n\n  function handleKeyUp(event) {\n    switch (event.key) {\n      case 'w':\n        movement.forward = false;\n        break;\n      case 'a':\n        movement.left = false;\n        break;\n      case 's':\n        movement.backward = false;\n        break;\n      case 'd':\n        movement.right = false;\n        break;\n      case 'q':\n        movement.up = false;\n        break;\n      case 'e':\n        movement.down = false;\n        break;\n    }\n  }\n\n  function updateCamera(deltaTime) {\n    const movementVector = new Vector3(0, 0, 0);\n\n    if (movement.forward) movementVector.add(Renderer.Camera.Orientation.forward);\n    if (movement.backward) movementVector.subtract(Renderer.Camera.Orientation.forward);\n    if (movement.left) movementVector.add(Renderer.Camera.Orientation.right);\n    if (movement.right) movementVector.add(Renderer.Camera.Orientation.right.clone().multiplyScalar(-1));\n    if (movement.up) movementVector.add(Renderer.Camera.Orientation.up);\n    if (movement.down) movementVector.subtract(Renderer.Camera.Orientation.up);\n\n    if (movementVector.magnitude() > 0) {\n      movementVector.normalize();\n      movementVector.multiplyScalar(-1 * deltaTime / 1000 * cameraSpeed);\n\n      Renderer.Camera.Position.add(movementVector);\n      Renderer.Camera.Position = Renderer.Camera.Position\n      moved = true;\n    }\n  }\n\n  document.addEventListener('keydown', handleKeyDown);\n  document.addEventListener('keyup', handleKeyUp);\n\n  const handleMouseMove = (event) => {\n    if (document.pointerLockElement === canvas) {\n      mouseX += event.movementX / mouseDPI;\n      mouseY -= event.movementY / mouseDPI;\n\n      if (mouseY > Math.PI) {\n        mouseY = Math.PI;\n      }\n\n      if (mouseY < -Math.PI) {\n        mouseY = -Math.PI;\n      }\n\n      setCameraRotation(mouseY, mouseX)\n      moved = true;\n    }\n  };\n\n  setCameraRotation(0, 0)\n  document.addEventListener('mousemove', handleMouseMove, false);\n\n  let lastCall = performance.now()\n  async function drawFrame() {\n    if(lastCompression != compression.value){\n        setCanvasSize(false)\n        lastCompression = compression.value\n    }\n\n    const deltaTime = performance.now() - lastCall\n    lastCall = performance.now()\n\n    // joysticks\n\n    let moveJoystickX = moveJoystick.GetX() / 100;\n    let moveJoystickY = moveJoystick.GetY() / 100;\n\n    let movePosition = Renderer.Camera.Orientation.forward.clone().multiplyScalar(-moveJoystickY)\n      .add(Renderer.Camera.Orientation.right.multiplyScalar(moveJoystickX)).normalize()\n      .multiplyScalar(deltaTime / 1000 * cameraSpeed);\n\n    if (movePosition.magnitude() > 0) {\n      Renderer.Camera.Position.add(movePosition);\n      Renderer.Camera.Position = Renderer.Camera.Position\n      moved = true;\n    }\n\n    let rotateJoystickX = rotateJoystick.GetX() / 100;\n    let rotateJoystickY = rotateJoystick.GetY() / 100;\n\n    mouseX += rotateJoystickX / mouseDPI * deltaTime;\n    mouseY += rotateJoystickY / mouseDPI * deltaTime;\n\n    if (mouseY > Math.PI) {\n      mouseY = Math.PI;//- Math.PI / 5;\n    }\n\n    if (mouseY < -Math.PI) {\n      mouseY = -Math.PI;//+ Math.PI / 5;\n    }\n\n    if (rotateJoystickX > 0 || rotateJoystickY > 0) {\n      setCameraRotation(mouseY, mouseX)\n    }\n\n    //\n\n    updateCamera(deltaTime)\n\n    if (Renderer.FramesStatic < 2048 || moved) {\n      let fovValue = FOV.value / 57.2958;\n      if (Renderer.Camera.FieldOfView !== fovValue) {\n        Renderer.Camera.FieldOfView = fovValue;\n      }\n\n      if (lastFPSDraw + 1000 <= Date.now()) {\n        lastFPSDraw = Date.now();\n        fpsCounter.textContent = `${FPSNumber} FPS`;\n        FPSNumber = 0;\n      }\n\n      sampleCounter.textContent = `${Renderer.FramesStatic} samples`;\n\n      await Renderer.MakeFrame();\n      await Renderer.RenderFrame();\n      FPSNumber += 1;\n      moved = false;\n    }\n\n    window.requestAnimationFrame(drawFrame)\n  }\n\n  window.requestAnimationFrame(drawFrame)\n}\n\ninit()/*.catch((err) => {\n  console.log(err.toString(), err.stack)\n})*/\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/index.js?");

/***/ }),

/***/ "./src/renderer/Camera.js":
/*!********************************!*\
  !*** ./src/renderer/Camera.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Vector3 = __webpack_require__(/*! ./classes/Vector3.js */ \"./src/renderer/classes/Vector3.js\")\nconst Matrix = __webpack_require__(/*! ./classes/Matrix.js */ \"./src/renderer/classes/Matrix.js\")\nconst Quaternion = __webpack_require__(/*! ./classes/Quaternion.js */ \"./src/renderer/classes/Quaternion.js\")\n\nclass Camera {\n    #Position = new Vector3(0, 0, 0);\n    #Orientation = new Quaternion(0, 0, 0, 1);\n    #FieldOfView = Math.PI / 2;\n\n    CameraToWorldMatrix = new Matrix(4, 4);\n    CameraMoved = false;\n\n    set FieldOfView(fov){\n        this.#FieldOfView = fov\n\n        this.CameraMoved = true;\n    }\n\n    get FieldOfView(){\n        return this.#FieldOfView\n    }\n\n    set Position(pos) {\n        this.#Position = pos\n        //this.#ComputeCameraToWorldMatrix()\n\n        this.CameraMoved = true;\n    }\n\n    get Position(){\n        return this.#Position\n    }\n\n    set Orientation(orientation) {\n        this.#Orientation = orientation\n        this.#ComputeCameraToWorldMatrix()\n\n        this.CameraMoved = true;\n    }\n\n    get Orientation(){\n        return this.#Orientation\n    }\n\n    #ComputeCameraToWorldMatrix() {\n        this.CameraToWorldMatrix.set(0, 0, this.Orientation.right.x  ); this.CameraToWorldMatrix.set(0, 1, this.Orientation.right.y );  this.CameraToWorldMatrix.set(0, 2, this.Orientation.right.z  ); this.CameraToWorldMatrix.set(0, 3, 0);\n        this.CameraToWorldMatrix.set(1, 0, this.Orientation.up.x     ); this.CameraToWorldMatrix.set(1, 1, this.Orientation.up.y    );  this.CameraToWorldMatrix.set(1, 2, this.Orientation.up.z     ); this.CameraToWorldMatrix.set(1, 3, 0);\n        this.CameraToWorldMatrix.set(2, 0, this.Orientation.forward.x); this.CameraToWorldMatrix.set(2, 1, this.Orientation.forward.y); this.CameraToWorldMatrix.set(2, 2, this.Orientation.forward.z); this.CameraToWorldMatrix.set(2, 3, 0);\n        this.CameraToWorldMatrix.set(3, 0, 0                         ); this.CameraToWorldMatrix.set(3, 1, 0                         ); this.CameraToWorldMatrix.set(3, 2, 0                         ); this.CameraToWorldMatrix.set(3, 3, 1);\n    }\n\n    SetOrientationMatrix(matrix){\n        const rotationMatrix = new Matrix(3, 3, [\n            matrix.get(0, 0), matrix.get(0, 1), matrix.get(0, 2),\n            matrix.get(1, 0), matrix.get(1, 1), matrix.get(1, 2),\n            matrix.get(2, 0), matrix.get(2, 1), matrix.get(2, 2)\n        ]);\n    \n        const translationVector = new Vector3(\n            matrix.get(0, 3),\n            matrix.get(1, 3),\n            matrix.get(2, 3)\n        );\n    \n        const trace = rotationMatrix.get(0, 0) + rotationMatrix.get(1, 1) + rotationMatrix.get(2, 2);\n        let qx, qy, qz, qw;\n    \n        if (trace > 0) {\n            const s = 0.5 / Math.sqrt(trace + 1.0);\n            qw = 0.25 / s;\n            qx = (rotationMatrix.get(2, 1) - rotationMatrix.get(1, 2)) * s;\n            qy = (rotationMatrix.get(0, 2) - rotationMatrix.get(2, 0)) * s;\n            qz = (rotationMatrix.get(1, 0) - rotationMatrix.get(0, 1)) * s;\n        } else if (rotationMatrix.get(0, 0) > rotationMatrix.get(1, 1) && rotationMatrix.get(0, 0) > rotationMatrix.get(2, 2)) {\n            const s = 2.0 * Math.sqrt(1.0 + rotationMatrix.get(0, 0) - rotationMatrix.get(1, 1) - rotationMatrix.get(2, 2));\n            qw = (rotationMatrix.get(2, 1) - rotationMatrix.get(1, 2)) / s;\n            qx = 0.25 * s;\n            qy = (rotationMatrix.get(0, 1) + rotationMatrix.get(1, 0)) / s;\n            qz = (rotationMatrix.get(0, 2) + rotationMatrix.get(2, 0)) / s;\n        } else if (rotationMatrix.get(1, 1) > rotationMatrix.get(2, 2)) {\n            const s = 2.0 * Math.sqrt(1.0 + rotationMatrix.get(1, 1) - rotationMatrix.get(0, 0) - rotationMatrix.get(2, 2));\n            qw = (rotationMatrix.get(0, 2) - rotationMatrix.get(2, 0)) / s;\n            qx = (rotationMatrix.get(0, 1) + rotationMatrix.get(1, 0)) / s;\n            qy = 0.25 * s;\n            qz = (rotationMatrix.get(1, 2) + rotationMatrix.get(2, 1)) / s;\n        } else {\n            const s = 2.0 * Math.sqrt(1.0 + rotationMatrix.get(2, 2) - rotationMatrix.get(0, 0) - rotationMatrix.get(1, 1));\n            qw = (rotationMatrix.get(1, 0) - rotationMatrix.get(0, 1)) / s;\n            qx = (rotationMatrix.get(0, 2) + rotationMatrix.get(2, 0)) / s;\n            qy = (rotationMatrix.get(1, 2) + rotationMatrix.get(2, 1)) / s;\n            qz = 0.25 * s;\n        }\n    \n        const quaternion = new Quaternion(qx, qy, qz, qw).normalize();\n\n        this.#Position = translationVector // only this one sets private, so that it doesnt call ComputeCameraToWorldMatrix \n        this.Orientation = quaternion;\n\n        this.CameraMoved = true;\n    }\n}\n\nmodule.exports = Camera\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/Camera.js?");

/***/ }),

/***/ "./src/renderer/Renderer.js":
/*!**********************************!*\
  !*** ./src/renderer/Renderer.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Camera = __webpack_require__(/*! ./Camera.js */ \"./src/renderer/Camera.js\")\n\nconst processorList = __webpack_require__(/*! ./post_processing/processorList.js */ \"./src/renderer/post_processing/processorList.js\")\n\nconst floatsPerTriangle = 4 * 3 + 4 * 3 + 2 * 2\nconst floatsPerMaterial = 4 + 4 + 4\n\nfunction closestPowerOfTwo(num) {\n    let power = 1;\n    while (power < num) {\n        power *= 2;\n    }\n\n    return power;\n}\n\nclass Renderer {\n    Camera = new Camera()\n\n    Frames = 0\n    FramesStatic = 0\n\n    //Denoiser = {type: \"none\"}\n    Denoiser = { type: \"ATrous\", levels: [3, 5, 7/*, 9, 11*/], c_phi: 0.75, n_phi: 0.005, p_phi: 0.25 }\n    PostProcessingStack = [\n        //new processorList.BloomProcessor()\n    ]\n\n    Map = []\n    Lights = []\n    Materials = {}\n    SampleSky = false\n\n    constructor({ Canvas }) {\n        this.Canvas = Canvas;\n    }\n\n    async Init() {\n        // init GPU\n\n        if (!navigator.gpu) {\n            throw new Error(\"WebGPU not supported.\");\n        }\n\n        this.adapter = await navigator.gpu.requestAdapter();\n        if (!this.adapter) {\n            throw new Error(\"Couldn't request WebGPU adapter.\");\n        }\n\n        let requiredFeatures = [\"float32-filterable\"]\n        for(let feature of requiredFeatures){\n            if(!this.adapter.features.has(feature)){\n                throw new Error(`Couldn't request ${feature}`);\n            }\n        }\n\n        this.Device = await this.adapter.requestDevice({\n            //requiredFeatures: [\"chromium-experimental-read-write-storage-texture\"],\n            requiredFeatures,\n        });\n\n        this.context = await this.Canvas.getContext(\"webgpu\")\n        this.preferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat()\n\n        this.context.configure({\n            device: this.Device,\n            format: this.preferredCanvasFormat,\n            alphaMode: \"premultiplied\",\n        });\n\n        // init buffers & layouts\n\n        await this.MakeLayouts();\n        this.#MakeStaticBuffers()\n        this.MakeBuffers(false);\n        this.#MakeStaticBindGroups()\n\n        this.SetMap([], {})\n        this.MakeBindGroups()\n\n\n        // post processing stack\n\n        for(let PostProcessingStackElement of this.PostProcessingStack ){\n            await PostProcessingStackElement.Init(this)\n            await PostProcessingStackElement.MakeBuffers()\n        }\n    }\n\n    async MakeLayouts() {\n        let rendererShaderModule = this.Device.createShaderModule({\n            code: await (await fetch(\"/renderer/shaders/renderer.wgsl\")).text(),\n        });\n\n        let tracerShaderModule = this.Device.createShaderModule({\n            code: await (await fetch(\"/renderer/shaders/tracer.wgsl\")).text(),\n        });\n\n        let denoiserShaderModule = this.Device.createShaderModule({\n            code: await (await fetch(\"/renderer/shaders/denoiser.wgsl\")).text(),\n        });\n\n        this.rendererDataBindGroupLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                }\n            ],\n        });\n\n        this.historyImageLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    storageTexture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n            ],\n        });\n\n        this.rendererTraceImageLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n            ],\n        });\n\n        this.tracerDataBindGroupLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                }\n            ],\n        });\n\n        this.tracerMapDataBindGroupLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n            ],\n        });\n\n        this.tracerTexturesLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba8snorm\",\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba16float\",\n                    },\n                }\n            ],\n        });\n\n        this.denoiserDataBindGroupLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                }\n            ],\n        });\n\n        this.denoiserTexturesLayout = this.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba8snorm\",\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba16float\",\n                    },\n                }\n            ],\n        });\n\n        let renderPipelineDescriptor = {\n            vertex: {\n                module: rendererShaderModule,\n                entryPoint: \"vertex_main\",\n                //buffers: vertexBuffers,\n            },\n            fragment: {\n                module: rendererShaderModule,\n                entryPoint: \"fragment_main\",\n                targets: [\n                    {\n                        format: this.preferredCanvasFormat,\n                    },\n                ],\n            },\n            primitive: {\n                topology: \"triangle-list\",\n            },\n            layout: this.Device.createPipelineLayout({\n                bindGroupLayouts: [this.rendererDataBindGroupLayout, this.historyImageLayout, this.rendererTraceImageLayout],\n            }),\n        };\n\n        let computePipelineDescriptor = {\n            compute: {\n                module: tracerShaderModule,\n                entryPoint: \"main\"\n            },\n            layout: this.Device.createPipelineLayout({\n                bindGroupLayouts: [this.tracerDataBindGroupLayout, this.tracerMapDataBindGroupLayout, this.tracerTexturesLayout]\n            }),\n        }\n\n        let denoiserPipelineDescriptor = {\n            compute: {\n                module: denoiserShaderModule,\n                entryPoint: \"main\"\n            },\n            layout: this.Device.createPipelineLayout({\n                bindGroupLayouts: [this.denoiserDataBindGroupLayout, this.denoiserTexturesLayout]\n            }),\n        }\n\n        this.renderPipeline = this.Device.createRenderPipeline(renderPipelineDescriptor);\n        this.tracerPipeline = this.Device.createComputePipeline(computePipelineDescriptor);\n        this.denoiserPipeline = this.Device.createComputePipeline(denoiserPipelineDescriptor);\n    }\n\n    #MakeStaticBuffers(){\n        this.GlobalDataBuffer = this.Device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n\n        this.CameraDataBuffer = this.Device.createBuffer({\n            size: 64 + 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n\n        this.DenoiserDataBuffer = this.Device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n    }\n\n    MakeBuffers(updatePostProcessStack) {\n        this.denoisedTexture = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n        this.historyImage = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.historyImageRead = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n\n\n        this.illuminationTexture = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.illuminationTextureRead = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n        this.normalTexture = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba8snorm',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.normalTextureRead = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba8snorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n        this.positionTexture = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba16float',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.positionTextureRead = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n        /*this.albedoTexture = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.albedoTextureRead = this.Device.createTexture({\n            size: [this.Canvas.width, this.Canvas.height],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });*/\n\n\n\n        if(updatePostProcessStack){\n            for(let PostProcessingStackElement of this.PostProcessingStack ){\n                PostProcessingStackElement.MakeBuffers()\n            }\n        }\n    }\n\n    #MakeStaticBindGroups(){\n        this.rendererDataBindGroup = this.Device.createBindGroup({\n            layout: this.rendererDataBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.GlobalDataBuffer,\n                    },\n                },\n            ],\n        });\n\n        this.tracerDataBindGroup = this.Device.createBindGroup({\n            layout: this.tracerDataBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.GlobalDataBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.CameraDataBuffer,\n                    },\n                },\n            ],\n        });\n\n        this.denoiserDataBindGroup = this.Device.createBindGroup({\n            layout: this.denoiserDataBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.GlobalDataBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.DenoiserDataBuffer,\n                    },\n                },\n            ],\n        });\n    }\n\n    MakeBindGroups(){\n        this.tracerTexturesBindGroup = this.Device.createBindGroup({\n            layout: this.tracerTexturesLayout,\n            entries: [\n                { binding: 0, resource: this.illuminationTexture.createView() },\n                { binding: 1, resource: this.normalTexture.createView() },\n                { binding: 2, resource: this.positionTexture.createView() },\n            ],\n        });\n\n        this.denoiserTexturesBindGroup = this.Device.createBindGroup({\n            layout: this.denoiserTexturesLayout,\n            entries: [\n                { binding: 0, resource: this.illuminationTexture.createView() },\n                { binding: 1, resource: this.illuminationTextureRead.createView() },\n                { binding: 2, resource: this.normalTextureRead.createView() },\n                { binding: 3, resource: this.positionTextureRead.createView() },\n            ],\n        });\n\n        this.historyBindGroup = this.Device.createBindGroup({\n            layout: this.historyImageLayout,\n            entries: [\n                { binding: 0, resource: this.historyImage.createView() },\n                { binding: 1, resource: this.historyImageRead.createView() },\n            ],\n        });\n\n        this.rendererTraceBindGrup = this.Device.createBindGroup({\n            layout: this.rendererTraceImageLayout,\n            entries: [\n                { binding: 0, resource: this.denoisedTexture.createView() },\n            ],\n        });\n    }\n\n    #MakeMapBindGroups(){\n        this.tracerMapDataBindGroup = this.Device.createBindGroup({\n            layout: this.tracerMapDataBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.mapBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.lightBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.materialBuffer,\n                    },\n                },\n                { \n                    binding: 3, \n                    resource: this.materialTextureMap.createView() \n                },\n            ],\n        });\n    }\n\n    #UpdateGlobalData() {\n        const globalViewData = new Float32Array([\n            this.Canvas.width, this.Canvas.height, // resolution\n            this.Frames,\n            this.FramesStatic\n        ]);\n\n        this.Device.queue.writeBuffer(this.GlobalDataBuffer, 0, globalViewData, 0, globalViewData.length);\n    }\n\n    #UpdateCameraData() {\n        const cameraData = new Float32Array([\n            ...this.Camera.CameraToWorldMatrix.data,\n            this.Camera.Position.x, this.Camera.Position.y, this.Camera.Position.z, // position\n            this.Camera.FieldOfView,\n        ]);\n\n        this.Device.queue.writeBuffer(this.CameraDataBuffer, 0, cameraData, 0, cameraData.length);\n        this.FramesStatic = 0;\n        this.Camera.CameraMoved = false\n    }\n\n    async #DenoiseFrame() {\n        switch (this.Denoiser.type) {\n            case \"none\":\n                var copyCommandEncoder = this.Device.createCommandEncoder();\n\n                copyCommandEncoder.copyTextureToTexture(\n                    {\n                        texture: this.illuminationTexture,\n                    },\n                    {\n                        texture: this.denoisedTexture,\n                    },\n                    {\n                        width: this.Canvas.width,\n                        height: this.Canvas.height,\n                        depthOrArrayLayers: 1,\n                    },\n                );\n\n                this.Device.queue.submit([copyCommandEncoder.finish()]);\n                break;\n            case \"ATrous\":\n                var copyCommandEncoder = this.Device.createCommandEncoder();\n\n                copyCommandEncoder.copyTextureToTexture(\n                    {\n                        texture: this.normalTexture,\n                    },\n                    {\n                        texture: this.normalTextureRead,\n                    },\n                    {\n                        width: this.Canvas.width,\n                        height: this.Canvas.height,\n                        depthOrArrayLayers: 1,\n                    },\n                );\n\n                copyCommandEncoder.copyTextureToTexture(\n                    {\n                        texture: this.positionTexture,\n                    },\n                    {\n                        texture: this.positionTextureRead,\n                    },\n                    {\n                        width: this.Canvas.width,\n                        height: this.Canvas.height,\n                        depthOrArrayLayers: 1,\n                    },\n                );\n\n                this.Device.queue.submit([copyCommandEncoder.finish()]);\n\n                for (let i = 0; i < this.Denoiser.levels.length; i++) {\n                    var textureCopyCommandEncoder = this.Device.createCommandEncoder();\n\n                    textureCopyCommandEncoder.copyTextureToTexture(\n                        {\n                            texture: this.illuminationTexture,\n                        },\n                        {\n                            texture: this.illuminationTextureRead,\n                        },\n                        {\n                            width: this.Canvas.width,\n                            height: this.Canvas.height,\n                            depthOrArrayLayers: 1,\n                        },\n                    );\n\n                    this.Device.queue.submit([textureCopyCommandEncoder.finish()]);\n\n                    var denoiserData = new Float32Array([\n                        this.Denoiser.c_phi,\n                        this.Denoiser.n_phi,\n                        this.Denoiser.p_phi,\n                        this.Denoiser.levels[i]\n                    ]);\n            \n                    this.Device.queue.writeBuffer(this.DenoiserDataBuffer, 0, denoiserData, 0, denoiserData.length);\n\n                    var commandEncoder = this.Device.createCommandEncoder();\n\n                    var passEncoder = commandEncoder.beginComputePass();\n                    passEncoder.setPipeline(this.denoiserPipeline);\n            \n                    passEncoder.setBindGroup(0, this.denoiserDataBindGroup);\n                    passEncoder.setBindGroup(1, this.denoiserTexturesBindGroup);\n            \n                    passEncoder.dispatchWorkgroups(this.Canvas.width / 8, this.Canvas.height / 8);\n                    passEncoder.end();\n            \n                    this.Device.queue.submit([commandEncoder.finish()]);\n            \n                    await this.Device.queue.onSubmittedWorkDone();\n                }\n\n                \n\n                var DenoisedTextureCopyCommandEncoder = this.Device.createCommandEncoder();\n\n                DenoisedTextureCopyCommandEncoder.copyTextureToTexture(\n                    {\n                        texture: this.illuminationTexture,\n                    },\n                    {\n                        texture: this.denoisedTexture,\n                    },\n                    {\n                        width: this.Canvas.width,\n                        height: this.Canvas.height,\n                        depthOrArrayLayers: 1,\n                    },\n                );\n\n                this.Device.queue.submit([DenoisedTextureCopyCommandEncoder.finish()]);\n\n                break;\n        }\n    }\n\n    async #UpdateTextures(){\n        if(!this.materialTextureMap){\n            this.materialTextureMap = this.Device.createTexture({\n                size: [this.Device.limits.maxTextureDimension2D, this.Device.limits.maxTextureDimension2D],\n                format: 'rgba8unorm',\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n            });\n        }\n        //this.MakeBindGroups()\n    }\n\n    async #UpdateMaterials(Materials){\n        let madeMapBindGroups = this.#UpdateTextures()\n\n        const MaterialKeys = Object.entries(Materials)\n        if(MaterialKeys.length != Object.keys(this.Materials).length || Object.keys(this.Materials).length == 0){\n            this.materialBuffer = this.Device.createBuffer({\n                size: (4 + (closestPowerOfTwo(Object.keys(Materials).length) * floatsPerMaterial)) * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n\n            if(!madeMapBindGroups){\n                this.#MakeMapBindGroups()\n            }\n        }\n    \n        const materialData = new Float32Array(4 + Object.keys(Materials).length * floatsPerMaterial);\n\n        materialData[0] = MaterialKeys.length;\n\n        let materialIndex = 0;\n        for(let [MaterialName, Material] of MaterialKeys){\n            let MaterialMemoryIndex = 4 + materialIndex * floatsPerMaterial;\n\n            materialData[MaterialMemoryIndex + 0] = Material.Color.x;\n            materialData[MaterialMemoryIndex + 1] = Material.Color.y;\n            materialData[MaterialMemoryIndex + 2] = Material.Color.z;\n            materialData[MaterialMemoryIndex + 3] = Material.Smoothness;\n            \n            materialData[MaterialMemoryIndex + 4] = Material.Emission.x;\n            materialData[MaterialMemoryIndex + 5] = Material.Emission.y;\n            materialData[MaterialMemoryIndex + 6] = Material.Emission.z;\n            materialData[MaterialMemoryIndex + 7] = Material.Specularity;\n\n            materialData[MaterialMemoryIndex + 8] = Material.Transparency;\n            \n            materialIndex += 1;\n        }\n\n        this.Device.queue.writeBuffer(this.materialBuffer, 0, materialData, 0, materialData.length);\n        this.Materials = Materials;\n\n        return madeMapBindGroups;\n    }\n\n    async #UpdateLights(Map, Materials){\n        let EmmisiveMaterials = Object.keys(Materials)\n                    .filter((Material) => Materials[Material].Emission.lengthSquared() > 0)\n\n        let Lights = Map.filter((Sphere) => EmmisiveMaterials.includes(Sphere.Material))\n\n        if(Lights.length !== this.Lights.length || this.Lights.length == 0){\n            this.lightBuffer = this.Device.createBuffer({\n                size: (4 + closestPowerOfTwo(Lights.length)) * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n        }\n\n        const lightData = new Float32Array(4 + Lights.length);\n\n        lightData[0] = Lights.length;\n        lightData[1] = this.SampleSky;\n\n        for(let LightIndex = 0; LightIndex < Lights.length; LightIndex++){\n            lightData[LightIndex + 4] = Map.indexOf(Lights[LightIndex]);\n        }\n\n        this.Device.queue.writeBuffer(this.lightBuffer, 0, lightData, 0, lightData.length);\n        this.Lights = Lights\n    }\n\n    async SetMap(Map, Materials){\n        let madeMapBindGroups = this.#UpdateMaterials(Materials)\n        this.Camera.CameraMoved = true\n\n        this.#UpdateLights(Map, Materials)\n\n        if(Map.length !== this.Map.length || this.Map.length == 0){\n            this.mapBuffer = this.Device.createBuffer({\n                size: (4 + (closestPowerOfTwo(Map.length) * floatsPerTriangle)) * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n\n            if(!madeMapBindGroups){\n                madeMapBindGroups = true;\n                this.#MakeMapBindGroups()\n            }\n        }\n\n        const MaterialKeys = Object.keys(Materials)\n        const mapData = new Float32Array(4 + Map.length * floatsPerTriangle);\n\n        mapData[0] = Map.length;\n\n        for(let [TriangleIndex, Triangle] of Map.entries()){\n            let TriangleMemoryIndex = 4 + TriangleIndex * floatsPerTriangle;\n\n            mapData[TriangleMemoryIndex + 0] = Triangle.a.x;\n            mapData[TriangleMemoryIndex + 1] = Triangle.a.y;\n            mapData[TriangleMemoryIndex + 2] = Triangle.a.z;\n            mapData[TriangleMemoryIndex + 3] = MaterialKeys.findIndex((value) => value == Triangle.Material);\n        \n            mapData[TriangleMemoryIndex + 4] = Triangle.b.x;\n            mapData[TriangleMemoryIndex + 5] = Triangle.b.y;\n            mapData[TriangleMemoryIndex + 6] = Triangle.b.z;\n\n            mapData[TriangleMemoryIndex + 8] = Triangle.c.x;\n            mapData[TriangleMemoryIndex + 9] = Triangle.c.y;\n            mapData[TriangleMemoryIndex + 10] = Triangle.c.z;\n\n            mapData[TriangleMemoryIndex + 12] = Triangle.na.x;\n            mapData[TriangleMemoryIndex + 13] = Triangle.na.y;\n            mapData[TriangleMemoryIndex + 14] = Triangle.na.z;\n        \n            mapData[TriangleMemoryIndex + 16] = Triangle.nb.x;\n            mapData[TriangleMemoryIndex + 17] = Triangle.nb.y;\n            mapData[TriangleMemoryIndex + 18] = Triangle.nb.z;\n\n            mapData[TriangleMemoryIndex + 20] = Triangle.nc.x;\n            mapData[TriangleMemoryIndex + 21] = Triangle.nc.y;\n            mapData[TriangleMemoryIndex + 22] = Triangle.nc.z;\n\n            mapData[TriangleMemoryIndex + 24] = Triangle.uva.x;\n            mapData[TriangleMemoryIndex + 25] = Triangle.uva.y;\n            mapData[TriangleMemoryIndex + 26] = Triangle.uvb.y;\n            mapData[TriangleMemoryIndex + 27] = Triangle.uvb.z;\n        }\n\n        this.Device.queue.writeBuffer(this.mapBuffer, 0, mapData, 0, mapData.length);\n        this.Map = Map\n\n        if(madeMapBindGroups){\n            this.#MakeMapBindGroups()\n        }\n    }\n\n    async MakeFrame() {\n        if (this.Camera.CameraMoved) {\n            this.#UpdateCameraData()\n        }\n\n        this.#UpdateGlobalData()\n        await this.#DenoiseFrame()\n\n        for(let PostProcessingStackElement of this.PostProcessingStack){\n            await PostProcessingStackElement.ProcessFrame();\n        }\n\n\n        const commandEncoder = this.Device.createCommandEncoder();\n\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(this.tracerPipeline);\n\n        passEncoder.setBindGroup(0, this.tracerDataBindGroup);\n        passEncoder.setBindGroup(1, this.tracerMapDataBindGroup);\n        passEncoder.setBindGroup(2, this.tracerTexturesBindGroup);\n\n        passEncoder.dispatchWorkgroups(this.Canvas.width / 8, this.Canvas.height / 8);\n        passEncoder.end();\n\n        this.Device.queue.submit([commandEncoder.finish()]);\n\n        await this.Device.queue.onSubmittedWorkDone();\n    }\n\n    async RenderFrame() {\n        // Copy history texture\n\n        const copyCommandEncoder = this.Device.createCommandEncoder();\n\n        copyCommandEncoder.copyTextureToTexture(\n            {\n                texture: this.historyImage,\n            },\n            {\n                texture: this.historyImageRead,\n            },\n            {\n                width: this.Canvas.width,\n                height: this.Canvas.height,\n                depthOrArrayLayers: 1,\n            },\n        );\n\n        this.Device.queue.submit([copyCommandEncoder.finish()]);\n\n        // Render\n\n        const commandEncoder = this.Device.createCommandEncoder();\n\n        const renderPassDescriptor = {\n            colorAttachments: [\n                {\n                    clearValue: { r: 1, g: 0, b: 1, a: 1 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\",\n                    view: this.context.getCurrentTexture().createView(),\n                },\n            ],\n        };\n\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n        passEncoder.setPipeline(this.renderPipeline);\n        passEncoder.setBindGroup(0, this.rendererDataBindGroup);\n        passEncoder.setBindGroup(1, this.historyBindGroup);\n        passEncoder.setBindGroup(2, this.rendererTraceBindGrup);\n        passEncoder.draw(3);\n\n        passEncoder.end();\n\n        this.Device.queue.submit([commandEncoder.finish()]);\n        await this.Device.queue.onSubmittedWorkDone();\n\n        this.Frames += 1;\n        this.FramesStatic += 1;\n    }\n}\n\nmodule.exports = Renderer\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/Renderer.js?");

/***/ }),

/***/ "./src/renderer/classes/Material.js":
/*!******************************************!*\
  !*** ./src/renderer/classes/Material.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Vector3 = __webpack_require__(/*! ./Vector3.js */ \"./src/renderer/classes/Vector3.js\")\n\nclass Material {\n    Color = new Vector3(1, 1, 1);\n    //SpecularColor = new Vector3(1, 1, 1);\n    Emission = new Vector3(0, 0, 0);\n\n    Smoothness = 0;\n    Specularity = 0;\n    Transparency = 1;\n}\n\nmodule.exports = Material\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/classes/Material.js?");

/***/ }),

/***/ "./src/renderer/classes/Matrix.js":
/*!****************************************!*\
  !*** ./src/renderer/classes/Matrix.js ***!
  \****************************************/
/***/ ((module) => {

eval("class Matrix {\n    constructor(rows, cols, initial) {\n        this.rows = rows;\n        this.cols = cols;\n        this.data = initial || new Array(rows * cols);\n    }\n\n    getIndex(row, col) {\n        return row * this.cols + col;\n    }\n\n    set(row, col, value) {\n        const index = this.getIndex(row, col);\n        if (index >= 0 && index < this.rows * this.cols) {\n            this.data[index] = value;\n        } else {\n            throw new Error('Index out of range');\n        }\n    }\n\n    get(row, col) {\n        const index = this.getIndex(row, col);\n\n        if (index >= 0 && index < this.rows * this.cols) {\n            return this.data[index];\n        } else {\n            throw new Error('Index out of range');\n        }\n    }\n\n    multiply(otherMatrix) {\n        if (this.cols !== otherMatrix.rows) {\n            throw new Error('Incompatible matrices for multiplication');\n        }\n\n        const result = new Matrix(this.rows, otherMatrix.cols);\n\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < otherMatrix.cols; j++) {\n                let sum = 0;\n\n                for (let k = 0; k < this.cols; k++) {\n                    sum += this.get(i, k) * otherMatrix.get(k, j);\n                }\n\n                result.set(i, j, sum);\n            }\n        }\n\n        return result;\n    }\n}\n\nmodule.exports = Matrix;\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/classes/Matrix.js?");

/***/ }),

/***/ "./src/renderer/classes/Quaternion.js":
/*!********************************************!*\
  !*** ./src/renderer/classes/Quaternion.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Matrix = __webpack_require__(/*! ./Matrix.js */ \"./src/renderer/classes/Matrix.js\")\nconst Vector3 = __webpack_require__(/*! ./Vector3.js */ \"./src/renderer/classes/Vector3.js\")\n\nclass Quaternion {\n    constructor(w, x, y, z) {\n        this.w = w || 0;\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n    }\n\n    get forward() {\n        return this.multiplyVector(new Vector3(0, 0, 1)).normalize();\n    }\n\n    get up() {\n        return this.multiplyVector(new Vector3(0, 1, 0)).normalize();\n    }\n\n    get right() {\n        return this.forward.cross(this.up).normalize();\n    }\n\n    multiplyVector(v) {\n        const qv = new Quaternion(0, v.x, v.y, v.z);\n        const conjugate = this.conjugate();\n        const rotatedVector = this.multiply(qv).multiply(conjugate);\n\n        return new Vector3(rotatedVector.x, rotatedVector.y, rotatedVector.z);\n    }\n\n    magnitude() {\n        return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n    normalize() {\n        const mag = this.magnitude();\n        this.w /= mag;\n        this.x /= mag;\n        this.y /= mag;\n        this.z /= mag;\n\n        return this;\n    }\n\n    multiply(q) {\n        const w = this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z;\n        const x = this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y;\n        const y = this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x;\n        const z = this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w;\n\n        return new Quaternion(w, x, y, z);\n    }\n\n    conjugate() {\n        return new Quaternion(this.w, -this.x, -this.y, -this.z);\n    }\n\n    setFromEulerAngles(xRotation, yRotation) {\n        xRotation = normalizeAngle(xRotation);\n        yRotation = normalizeAngle(yRotation);\n\n        const halfX = xRotation / 2;\n        const halfY = yRotation / 2;\n\n        const cosHalfX = Math.cos(halfX);\n        const sinHalfX = Math.sin(halfX);\n        const cosHalfY = Math.cos(halfY);\n        const sinHalfY = Math.sin(halfY);\n\n        this.w = cosHalfX * cosHalfY;\n        this.x = sinHalfX * cosHalfY;\n        this.y = cosHalfX * sinHalfY;\n        this.z = -sinHalfX * sinHalfY;\n\n        return this;\n    }\n\n    getEulerAngles(){\n        const { x, y, z, w } = this;\n\n        const sinP = 2.0 * (w * x + y * z);\n        const cosP = 1.0 - 2.0 * (x * x + y * y);\n        const pitch = Math.atan2(sinP, cosP);\n    \n        const sinY = 2.0 * (w * y - z * x);\n        const cosY = 1.0 - 2.0 * (y * y + z * z);\n        const yaw = Math.atan2(sinY, cosY);\n    \n        const sinR = 2.0 * (w * z + x * y);\n        const cosR = 1.0 - 2.0 * (y * y + z * z);\n        const roll = Math.atan2(sinR, cosR);\n    \n        return new Vector3(pitch, yaw, roll);\n    }\n\n    toRotationMatrix() {\n        const { w, x, y, z } = this;\n        const xx = x * x;\n        const yy = y * y;\n        const zz = z * z;\n        const xy = x * y;\n        const xz = x * z;\n        const yz = y * z;\n        const wx = w * x;\n        const wy = w * y;\n        const wz = w * z;\n\n        return new Matrix(3, 3, [\n            1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy),\n            2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx),\n            2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy)\n        ]);\n    }\n}\n\nfunction normalizeAngle(angle) {\n    angle %= 2 * Math.PI;\n    \n    if (angle > Math.PI) {\n        angle -= 2 * Math.PI;\n    } else if (angle < -Math.PI) {\n        angle += 2 * Math.PI;\n    }\n\n    return angle;\n}\n\n\nmodule.exports = Quaternion;\n\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/classes/Quaternion.js?");

/***/ }),

/***/ "./src/renderer/classes/Triangle.js":
/*!******************************************!*\
  !*** ./src/renderer/classes/Triangle.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Vector3 = __webpack_require__(/*! ./Vector3.js */ \"./src/renderer/classes/Vector3.js\")\nconst Vector2 = __webpack_require__(/*! ./Vector2.js */ \"./src/renderer/classes/Vector2.js\")\n\nclass Triangle {\n    a = new Vector3(0, 0, 0);\n    b = new Vector3(0, 0, 0);\n    c = new Vector3(0, 0, 0);\n\n    na = new Vector3(0, 0, 0);\n    nb = new Vector3(0, 0, 0);\n    nc = new Vector3(0, 0, 0);\n    \n    uva = new Vector2(0, 0, 0);\n    uvb = new Vector2(0, 0, 0);\n\n    Material = \"default\";\n}\n\nmodule.exports = Triangle\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/classes/Triangle.js?");

/***/ }),

/***/ "./src/renderer/classes/Vector2.js":
/*!*****************************************!*\
  !*** ./src/renderer/classes/Vector2.js ***!
  \*****************************************/
/***/ ((module) => {

eval("class Vector2 {\n    constructor(x, y) {\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    normalize() {\n        const mag = this.magnitude();\n        if (mag !== 0) {\n            this.x /= mag;\n            this.y /= mag;\n        }\n    }\n\n    add(v) {\n        this.x += v.x;\n        this.y += v.y;\n    }\n\n    subtract(v) {\n        this.x -= v.x;\n        this.y -= v.y;\n    }\n\n    dot(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n\n    multiplyScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n    }\n\n    clone() {\n        return new Vector2(this.x, this.y);\n    }\n\n    static distance(v1, v2) {\n        const dx = v1.x - v2.x;\n        const dy = v1.y - v2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\nmodule.exports = Vector2;\n\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/classes/Vector2.js?");

/***/ }),

/***/ "./src/renderer/classes/Vector3.js":
/*!*****************************************!*\
  !*** ./src/renderer/classes/Vector3.js ***!
  \*****************************************/
/***/ ((module) => {

eval("class Vector3 {\n    constructor(x, y, z) {\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n    }\n\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n\n    normalize() {\n        const mag = this.magnitude();\n        if (mag !== 0) {\n            this.x /= mag;\n            this.y /= mag;\n            this.z /= mag;\n        }\n\n        return this;\n    }\n\n    add(v) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n\n        return this;\n    }\n\n    subtract(v) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n\n        return this;\n    }\n\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n\n    cross(v) {\n        const x = this.y * v.z - this.z * v.y;\n        const y = this.z * v.x - this.x * v.z;\n        const z = this.x * v.y - this.y * v.x;\n        return new Vector3(x, y, z);\n    }\n\n    multiplyScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n\n        return this;\n    }\n\n    clone() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n\n    static distance(v1, v2) {\n        const dx = v1.x - v2.x;\n        const dy = v1.y - v2.y;\n        const dz = v1.z - v2.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\n\nmodule.exports = Vector3;\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/classes/Vector3.js?");

/***/ }),

/***/ "./src/renderer/post_processing/bloom/processor.js":
/*!*********************************************************!*\
  !*** ./src/renderer/post_processing/bloom/processor.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("class BloomProcessor {\n    Renderer;\n\n    async Init(Renderer){\n        this.Renderer = Renderer;\n\n        let downsampleShaderModule = this.Renderer.Device.createShaderModule({\n            code: await (await fetch(\"/renderer/post_processing/bloom/downsample.wgsl\")).text(),\n        });\n\n        let thresholdShaderModule = this.Renderer.Device.createShaderModule({\n            code: await (await fetch(\"/renderer/post_processing/bloom/threshold.wgsl\")).text(),\n        });\n\n        let overlapShaderModule = this.Renderer.Device.createShaderModule({\n            code: await (await fetch(\"/renderer/post_processing/bloom/overlap.wgsl\")).text(),\n        });\n\n        this.dataBindGroupLayout = this.Renderer.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                }\n            ],\n        });\n\n        this.downsampleTexturesLayout = this.Renderer.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba32float\",\n                    },\n                },\n            ],\n        });\n\n        this.thresholdTexturesLayout = this.Renderer.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba32float\",\n                    },\n                },\n            ],\n        });\n\n        this.overlapTexturesLayout = this.Renderer.Device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        format: \"rgba32float\",\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        format: \"rgba32float\",\n                    },\n                },\n            ],\n        });\n\n        let downsamplePipelineDescriptor = {\n            compute: {\n                module: downsampleShaderModule,\n                entryPoint: \"main\"\n            },\n            layout: this.Renderer.Device.createPipelineLayout({\n                bindGroupLayouts: [this.dataBindGroupLayout, this.downsampleTexturesLayout]\n            }),\n        }\n\n        let thresholdPipelineDescriptor = {\n            compute: {\n                module: thresholdShaderModule,\n                entryPoint: \"main\"\n            },\n            layout: this.Renderer.Device.createPipelineLayout({\n                bindGroupLayouts: [this.dataBindGroupLayout, this.thresholdTexturesLayout]\n            }),\n        }\n\n        let overlapPipelineDescriptor = {\n            compute: {\n                module: overlapShaderModule,\n                entryPoint: \"main\"\n            },\n            layout: this.Renderer.Device.createPipelineLayout({\n                bindGroupLayouts: [this.dataBindGroupLayout, this.overlapTexturesLayout]\n            }),\n        }\n\n        this.downsamplePipeline = this.Renderer.Device.createComputePipeline(downsamplePipelineDescriptor);\n        this.thresholdPipeline = this.Renderer.Device.createComputePipeline(thresholdPipelineDescriptor);\n        this.overlapPipeline = this.Renderer.Device.createComputePipeline(overlapPipelineDescriptor);\n    }\n\n    MakeBuffers() {\n        this.quarterTexture = this.Renderer.Device.createTexture({\n            size: [this.Renderer.Canvas.width / 2, this.Renderer.Canvas.height / 2],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.quarterTextureRead = this.Renderer.Device.createTexture({\n            size: [this.Renderer.Canvas.width / 2, this.Renderer.Canvas.height / 2],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n        this.thresholdTexture = this.Renderer.Device.createTexture({\n            size: [this.Renderer.Canvas.width / 2, this.Renderer.Canvas.height / 2],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.thresholdTextureRead = this.Renderer.Device.createTexture({\n            size: [this.Renderer.Canvas.width / 2, this.Renderer.Canvas.height / 2],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n\n        this.outputImage = this.Renderer.Device.createTexture({\n            size: [this.Renderer.Canvas.width, this.Renderer.Canvas.height],\n            format: 'rgba32float',\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        });\n\n        this.dataBindGroup = this.Renderer.Device.createBindGroup({\n            layout: this.dataBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.Renderer.GlobalDataBuffer,\n                    },\n                }\n            ]\n        })\n\n        this.downsampleTexturesBindGroup = this.Renderer.Device.createBindGroup({\n            layout: this.downsampleTexturesLayout,\n            entries: [\n                { binding: 0, resource: this.Renderer.illuminationTextureRead.createView() },\n                { binding: 1, resource: this.quarterTexture.createView() },\n            ],\n        });\n\n        this.thresholdTexturesBindGroup = this.Renderer.Device.createBindGroup({\n            layout: this.thresholdTexturesLayout,\n            entries: [\n                { binding: 0, resource: this.quarterTextureRead.createView() },\n                { binding: 1, resource: this.thresholdTexture.createView() },\n            ],\n        });\n\n        this.overlapTexturesBindGroup = this.Renderer.Device.createBindGroup({\n            layout: this.overlapTexturesLayout,\n            entries: [\n                { binding: 0, resource: this.thresholdTextureRead.createView() },\n                { binding: 1, resource: this.Renderer.illuminationTextureRead.createView() },\n                { binding: 2, resource: this.outputImage.createView() },\n            ],\n        });\n    }\n\n    async #DownsampleFrame(){\n        // downsample\n        var commandEncoder = this.Renderer.Device.createCommandEncoder();\n\n        var passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(this.downsamplePipeline);\n\n        passEncoder.setBindGroup(0, this.dataBindGroup);\n        passEncoder.setBindGroup(1, this.downsampleTexturesBindGroup);\n\n        passEncoder.dispatchWorkgroups(this.Renderer.Canvas.width / 16, this.Renderer.Canvas.height / 16);\n        passEncoder.end();\n\n        this.Renderer.Device.queue.submit([commandEncoder.finish()]);\n\n        await this.Renderer.Device.queue.onSubmittedWorkDone();\n\n        // copy downsampled texture\n        let textureCopyCommandEncoder = this.Renderer.Device.createCommandEncoder();\n\n        textureCopyCommandEncoder.copyTextureToTexture(\n            {\n                texture: this.quarterTexture,\n            },\n            {\n                texture: this.quarterTextureRead,\n            },\n            {\n                width: this.Renderer.Canvas.width / 2,\n                height: this.Renderer.Canvas.height / 2,\n                depthOrArrayLayers: 1,\n            },\n        );\n\n        this.Renderer.Device.queue.submit([textureCopyCommandEncoder.finish()]);\n    }\n\n    async #ThresholdFrame(){\n        // threshold\n        var commandEncoder = this.Renderer.Device.createCommandEncoder();\n\n        var passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(this.thresholdPipeline);\n\n        passEncoder.setBindGroup(0, this.dataBindGroup);\n        passEncoder.setBindGroup(1, this.thresholdTexturesBindGroup);\n\n        passEncoder.dispatchWorkgroups(this.Renderer.Canvas.width / 16, this.Renderer.Canvas.height / 16);\n        passEncoder.end();\n\n        this.Renderer.Device.queue.submit([commandEncoder.finish()]);\n\n        await this.Renderer.Device.queue.onSubmittedWorkDone();\n\n        // copy threshold texture\n        let textureCopyCommandEncoder = this.Renderer.Device.createCommandEncoder();\n\n        textureCopyCommandEncoder.copyTextureToTexture(\n            {\n                texture: this.thresholdTexture,\n            },\n            {\n                texture: this.thresholdTextureRead,\n            },\n            {\n                width: this.Renderer.Canvas.width / 2,\n                height: this.Renderer.Canvas.height / 2,\n                depthOrArrayLayers: 1,\n            },\n        );\n\n        this.Renderer.Device.queue.submit([textureCopyCommandEncoder.finish()]);\n    }\n\n    async #OverlapFrame(){\n        // overlap\n        var commandEncoder = this.Renderer.Device.createCommandEncoder();\n\n        var passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(this.overlapPipeline);\n\n        passEncoder.setBindGroup(0, this.dataBindGroup);\n        passEncoder.setBindGroup(1, this.overlapTexturesBindGroup);\n\n        passEncoder.dispatchWorkgroups(this.Renderer.Canvas.width / 8, this.Renderer.Canvas.height / 8);\n        passEncoder.end();\n\n        this.Renderer.Device.queue.submit([commandEncoder.finish()]);\n\n        await this.Renderer.Device.queue.onSubmittedWorkDone();\n\n        // copy overlapped texture\n        let textureCopyCommandEncoder = this.Renderer.Device.createCommandEncoder();\n\n        textureCopyCommandEncoder.copyTextureToTexture(\n            {\n                texture: this.outputImage,\n            },\n            {\n                texture: this.Renderer.denoisedTexture,\n            },\n            {\n                width: this.Renderer.Canvas.width,\n                height: this.Renderer.Canvas.height,\n                depthOrArrayLayers: 1,\n            },\n        );\n\n        this.Renderer.Device.queue.submit([textureCopyCommandEncoder.finish()]);\n    }\n\n    async ProcessFrame(){\n        await this.#DownsampleFrame()\n        await this.#ThresholdFrame()\n        await this.#OverlapFrame()\n    }\n}\n\nmodule.exports = BloomProcessor\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/post_processing/bloom/processor.js?");

/***/ }),

/***/ "./src/renderer/post_processing/processorList.js":
/*!*******************************************************!*\
  !*** ./src/renderer/post_processing/processorList.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let BloomProcessor = __webpack_require__(/*! ./bloom/processor.js */ \"./src/renderer/post_processing/bloom/processor.js\")\n\nmodule.exports = {\n    BloomProcessor\n}\n\n//# sourceURL=webpack://ray_tracer_webgpu/./src/renderer/post_processing/processorList.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;